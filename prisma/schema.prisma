// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

/**
 * =========================
 * DOMAIN ENUMS (PG enums)
 * =========================
 */

enum export_type {
  wav
  mp4
  mp4_captions
}

enum export_state {
  queued
  running
  succeeded
  failed
}

enum job_state {
  queued
  running
  succeeded
  failed
  dead
}

enum job_type {
  transcode
  asr
  export
}

enum recording_status {
  draft
  uploading
  processing
  ready
  error
}

enum track_kind {
  audio
  video
  screen
}

enum track_state {
  recording
  uploaded
  processed
}

model User {
  id        String   @id @default(uuid()) @db.Uuid
  email     String   @unique @db.Text
  name      String?  @db.Text
  imageUrl  String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  accounts      OAuthAccount[]
  refreshTokens RefreshToken[]

  recordings   recording[] // owns these recordings
  participants participant[] // optional: rows where the user is a participant

  @@map("user_account")
}

model OAuthAccount {
  id             String   @id @default(uuid()) @db.Uuid
  userId         String   @db.Uuid
  provider       String   @db.Text // "google" | "github" | etc
  providerUserId String   @db.Text // external subject/user id
  email          String?  @db.Text
  profileJson    Json?    @map("profile_json")
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUserId], map: "uq_oauth_provider_user")
  @@index([userId])
  @@map("oauth_account")
}

model RefreshToken {
  id          String    @id @default(uuid()) @db.Uuid
  userId      String    @db.Uuid
  jti         String    @unique @db.Text // token id
  hashedToken String    @map("hashed_token") @db.Text
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  expiresAt   DateTime  @map("expires_at") @db.Timestamptz(6)
  revokedAt   DateTime? @map("revoked_at") @db.Timestamptz(6)
  userAgent   String?   @map("user_agent") @db.Text
  ip          String?   @db.Text

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_token")
}

/**
 * =========================
 * RECORDING MODELS
 * =========================
 */

model recording {
  id         String           @id @default(uuid()) @db.Uuid
  title      String?
  status     recording_status @default(draft)
  created_at DateTime         @default(now()) @db.Timestamptz(6)

  userId String? @db.Uuid
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: NoAction)

  clip               clip[]
  job                job[]
  participant        participant[]
  track              track[]
  transcript_segment transcript_segment[]
  export_artifact    export_artifact[] // ðŸ”¹ NEW back-relation

  @@index([userId], map: "idx_recording_user")
}

model participant {
  id              String  @id @default(uuid()) @db.Uuid
  recording_id    String  @db.Uuid
  role            String  @db.Text // 'host' | 'guest' (DB CHECK)
  display_name    String? @db.Text
  email           String? @db.Text
  magic_link_hash String? @db.Text // for guest invite/claim

  // OPTIONAL link to a registered user (if they signed in)
  userId String? @db.Uuid
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull, onUpdate: NoAction)

  recording recording @relation(fields: [recording_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  track     track[]

  @@index([recording_id])
  @@index([userId], map: "idx_participant_user")
  @@map("participant")
}

model track {
  id                String      @id @default(uuid()) @db.Uuid
  recording_id      String      @db.Uuid
  participant_id    String      @db.Uuid
  kind              track_kind
  codec             String?     @db.Text
  duration_ms       Int?
  storage_key_raw   String?     @db.Text
  storage_key_final String?     @db.Text
  state             track_state @default(recording)
  created_at        DateTime    @default(now()) @db.Timestamptz(6)

  participant        participant          @relation(fields: [participant_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  recording          recording            @relation(fields: [recording_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  upload             upload[]
  transcript_segment transcript_segment[] // ðŸ”¹ NEW back-relation

  @@index([recording_id], map: "idx_track_recording")
  @@map("track")
}

model upload {
  id             String   @id @default(uuid()) @db.Uuid
  track_id       String   @db.Uuid
  protocol       String   @db.Text
  bytes_received BigInt   @default(0)
  parts_json     Json?
  etag           String?  @db.Text
  state          String   @db.Text
  updated_at     DateTime @default(now()) @db.Timestamptz(6)

  // âœ¨ multipart additions
  storage_bucket String? @db.Text
  object_key     String? @db.Text
  multipart_id   String? @db.Text
  part_size      Int?
  expected_size  BigInt?
  completion_sig String? @db.Text

  track  track         @relation(fields: [track_id], references: [id], onDelete: Cascade)
  tusMap UploadTusMap?

  @@index([state, updated_at], map: "idx_upload_state_updated") // handy for cleanup/scans
  @@map("upload")
}

model job {
  id           String    @id @default(uuid()) @db.Uuid
  recording_id String    @db.Uuid
  type         job_type
  payload_json Json?
  state        job_state @default(queued)
  attempts     Int       @default(0)
  last_error   String?   @db.Text
  created_at   DateTime  @default(now()) @db.Timestamptz(6)

  recording recording @relation(fields: [recording_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([state], map: "idx_job_state")
  @@map("job")
}

model transcript_segment {
  id           String   @id @default(uuid()) @db.Uuid
  recording_id String   @db.Uuid
  track_id     String?  @db.Uuid // ðŸ”¹ NEW: ties segment to a specific track
  speaker      String?  @db.Text
  start_ms     Int
  end_ms       Int
  text         String   @db.Text
  confidence   Decimal? @db.Decimal

  recording recording @relation(fields: [recording_id], references: [id], onDelete: Cascade, onUpdate: NoAction)
  track     track?    @relation(fields: [track_id], references: [id], onDelete: SetNull, onUpdate: NoAction)

  @@index([recording_id], map: "idx_transcript_recording")
  @@index([track_id], map: "idx_transcript_track") // ðŸ”¹ helpful for per-track queries
  @@map("transcript_segment")
}

model clip {
  id           String   @id @default(uuid()) @db.Uuid
  recording_id String   @db.Uuid
  start_ms     Int
  end_ms       Int
  title        String?  @db.Text
  keywords     String[] @db.Text

  recording recording @relation(fields: [recording_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@map("clip")
}

model UploadTusMap {
  uploadId  String   @id @map("upload_id") @db.Uuid
  tusId     String   @unique @map("tus_id")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  upload upload @relation(fields: [uploadId], references: [id], onDelete: Cascade)

  @@map("upload_tus_map")
}

model export_artifact {
  id           String       @id @default(uuid()) @db.Uuid
  recording_id String       @db.Uuid
  type         export_type
  state        export_state @default(queued)
  storage_key  String?      @db.Text
  last_error   String?      @db.Text
  created_at   DateTime     @default(now()) @db.Timestamptz(6)
  updated_at   DateTime     @updatedAt @db.Timestamptz(6)

  recording recording @relation(fields: [recording_id], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@index([recording_id], map: "idx_export_recording")
  @@map("export_artifact")
}
